package main

import (
	"flag"
	"log"
	"math"
	"math/rand"
	"time"

	"github.com/gotk3/gotk3/cairo"
	"github.com/gotk3/gotk3/gdk"
	"github.com/gotk3/gotk3/gtk"
)

const (
	// App
	appName       = "GoLock"
	indicatorName = "GoLockIndicator"

	// Sizes
	buttonRadius   = 90
	buttonSpace    = buttonRadius + 5
	buttonCenter   = buttonRadius + 5
	buttonDiameter = 2 * buttonSpace
	// scale          = 0.9

	// Math
	pi = math.Pi

	// Draw
	redrawTo = 2 * time.Second

	// Font
	fontFamily = "Hack"
	fontSize   = 16.0
)

var (
	// Sizes
	height float64
	width  float64

	// Window
	windowAlpha float64
)

func init() {
	flag.Float64Var(&height, "h", 1080, "window height")
	flag.Float64Var(&width, "w", 1920, "window width")
	flag.Float64Var(&windowAlpha, "a", 0.5, "window alpha")
}

type App struct {
	Window         *gtk.Window
	OverlayWindow  *gtk.Window
	AlphaSupported bool
}

func (a *App) SetMainSourceRGBA(ctx *cairo.Context) {
	switch state.LastEvent {
	case AuthSuccessEvent:
		ctx.SetSourceRGB(51.0/255, 125.0/255, 0)
	case AuthCheckEvent:
		ctx.SetSourceRGBA(0, 144.0/255, 255.0/255, 0.75)
	case CapsChangedEvent:
		if state.IsCapsLockOn {
			ctx.SetSourceRGBA(0, 144.0/255, 255.0/255, 0.75)
		} else {
			ctx.SetSourceRGBA(0, 144.0/255, 255.0/255, 0.75)
		}
		break
	case EmptyPasswordEvent, WrongPasswordEvent, BackSpaceEvent:
		ctx.SetSourceRGBA(250.0/255, 0, 0, 0.75)
		break
	case KeyPressEvent:
		ctx.SetSourceRGBA(0, 0, 0, 0.5)
		break
	}
}

func (a *App) SetMainSourceRGB(ctx *cairo.Context) {
	switch state.LastEvent {
	case AuthSuccessEvent:
		ctx.SetSourceRGB(51.0/255, 125.0/255, 0)
	case AuthCheckEvent:
		ctx.SetSourceRGB(51.0/255, 0, 250.0/255)
	case CapsChangedEvent:
		if state.IsCapsLockOn {
			ctx.SetSourceRGB(51.0/255, 0, 250.0/255)
		} else {
			ctx.SetSourceRGB(51.0/255, 0, 250.0/255)
		}
		break
	case EmptyPasswordEvent, WrongPasswordEvent, BackSpaceEvent:
		ctx.SetSourceRGB(125.0/255, 51.0/255, 0)
		break
	case KeyPressEvent:
		ctx.SetSourceRGB(51.0/255, 125.0/255, 0)
		break
	}
}

func (a *App) DrawStateText(ctx *cairo.Context) {
	// Setup font settings
	ctx.SetSourceRGB(255, 255, 255)
	ctx.SetLineWidth(10.0)
	ctx.SelectFontFace(fontFamily, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
	ctx.SetFontSize(fontSize)

	// Set text
	var text string
	switch state.LastEvent {
	case AuthSuccessEvent:
		text = "Success!"
	case AuthCheckEvent:
		text = "Checking..."
	case EmptyPasswordEvent:
		text = "No input"
	case WrongPasswordEvent:
		text = "Wrong"
	default:
		if state.IsCapsLockOn {
			text = "CapsLock ON"
		}
	}

	if text == "" {
		return
	}

	extents := ctx.TextExtents(text)
	x := buttonRadius + 10 - ((extents.Width / 2) + extents.XBearing)
	y := buttonRadius + 10 - ((extents.Height / 2) + extents.YBearing)

	ctx.MoveTo(x, y)
	ctx.ShowText(text)
	ctx.ClosePath()
}

func (a *App) CreateKeyPressArc(ctx *cairo.Context) {
	switch state.LastEvent {
	case BackSpaceEvent:
		if state.PasswordLength == 0 {
			return
		}

		fallthrough
	case KeyPressEvent:
		ctx.SetSourceRGBA(0, 0, 0, 0.5)
		ctx.SetLineWidth(11.0)
		startRadians := 2 * pi * 100
		var start int32
		for start == state.LastStart {
			start = (rand.Int31() % int32(startRadians)) / 100
		}

		state.LastStart = start
		endRadians := (pi / 3)
		ctx.Arc(buttonRadius+10, buttonRadius+10, buttonRadius+1, float64(start), float64(start+int32(endRadians)))
		ctx.Stroke()
		break
	}
}

func (a *App) Draw(ctx *cairo.Context) {
	log.Println("Draw started")
	if state.LastEvent == NoEvent || !state.ShouldDraw {
		return
	}

	ctx.SetLineWidth(10.0)
	ctx.Arc(buttonRadius+10, buttonRadius+10, buttonRadius, 0, 2*pi)
	a.SetMainSourceRGBA(ctx)
	ctx.FillPreserve()
	a.SetMainSourceRGB(ctx)
	ctx.Stroke()

	ctx.SetSourceRGB(0, 0, 0)
	ctx.SetLineWidth(2.0)
	ctx.Arc(buttonRadius+10, buttonRadius+10, buttonRadius-5, 0, 2*pi)
	ctx.Stroke()

	a.CreateKeyPressArc(ctx)

	a.DrawStateText(ctx)
	log.Println("Draw ended")
}

func (a *App) QueueRedraw(willClear bool) {
	state.ShouldDraw = true
	a.Window.QueueDraw()
	if !willClear {
		return
	}

	go func() {
		now := time.Now()
		state.LastQueuedRedraw = now
		time.Sleep(redrawTo)

		if !state.LastQueuedRedraw.Equal(now) {
			return
		}

		state.ShouldDraw = false
		a.Window.QueueDraw()
	}()
}

func (a *App) screenChanged(widget *gtk.Widget) {
	screen, _ := widget.GetScreen()
	visual, _ := screen.GetRGBAVisual()

	if visual != nil {
		a.AlphaSupported = true
	} else {
		log.Println("Alpha not supported")
		a.AlphaSupported = false
	}

	widget.SetVisual(visual)
}

func (a *App) exposeDraw(w *gtk.Window, ctx *cairo.Context) {
	if a.AlphaSupported {
		ctx.SetSourceRGBA(0.0, 0.0, 0.0, windowAlpha)
	} else {
		ctx.SetSourceRGB(0.0, 0.0, 0.0)
	}

	ctx.SetOperator(cairo.OPERATOR_SOURCE)
	ctx.Paint()
}

var app *App

func watchState(done chan bool) {
	for {
		select {
		case event := <-state.EventChan:
			log.Println("New Event!")
			state.LastEvent = event
			app.QueueRedraw(true)
		case <-done:
			done <- true
			return
		}
	}
}

func createOverlay() {
	win, err := gtk.WindowNew(gtk.WINDOW_POPUP)
	if err != nil {
		log.Fatal("Unable to create window:", err)
	}

	app.OverlayWindow = win
	win.SetTitle(appName)
	win.Connect("destroy", func() {
		gtk.MainQuit()
	})

	// Needed for transparency
	win.SetAppPaintable(true)

	win.Connect("screen-changed", func(widget *gtk.Widget, oldScreen *gdk.Screen, userData ...interface{}) {
		app.screenChanged(widget)
	})

	win.Connect("draw", func(window *gtk.Window, context *cairo.Context) {
		log.Println("DRAW overlay")
		app.exposeDraw(window, context)
	})

	win.SetDefaultSize(int(width), int(height))
	app.screenChanged(&app.OverlayWindow.Widget)

	win.ShowAll()
}

func createIndicator() {
	win, err := gtk.WindowNew(gtk.WINDOW_POPUP)
	if err != nil {
		log.Fatal("Unable to create window:", err)
	}

	app.Window = win
	win.SetTitle(indicatorName)
	win.Connect("destroy", func() {
		gtk.MainQuit()
	})

	win.Connect("screen-changed", func(widget *gtk.Widget, oldScreen *gdk.Screen, userData ...interface{}) {
		app.screenChanged(widget)
	})

	win.Connect("draw", func(window *gtk.Window, context *cairo.Context) {
		log.Println("DRAW indicator")
		app.exposeDraw(window, context)
		app.Draw(context)
	})

	win.SetDefaultSize(int(width), int(height))
	win.Move(int((width/2)-buttonRadius), int((height/2)-buttonRadius))

	win.ShowAll()
}

func startApp(done chan bool) {
	app = &App{}
	gtk.Init(nil)

	createOverlay()
	createIndicator()

	go watchState(done)

	gtk.Main()
}

